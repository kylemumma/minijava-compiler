/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal CLASS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal STRING;
terminal EXTENDS;
terminal RETURN;
terminal INT;
terminal BOOLEAN;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PRINT;
terminal TRUE;
terminal FALSE;
terminal THIS;
terminal NEW;
terminal LENGTH;

/* operators */
terminal PLUS, BECOMES;
terminal AND, NOT;
terminal LESSTHAN;
terminal MINUS, TIMES;

/* delimiters */
terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal LCURLY, RCURLY;
terminal SEMICOLON, COMMA, DOT;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

/* ------------ OLD NONTERMINALS --------------
non terminal List<Statement> Program;
non terminal Statement Statement;
non terminal Assign AssignStatement;
non terminal Exp Expression;
non terminal Identifier Identifier;
*/
// todo: add types to these, corresponding to the AST node type for the given
// production (i think)
non terminal Goal;
non terminal MainClass;
non terminal ClassDeclarations;
non terminal ClassDeclaration;
non terminal VarDeclaration;
non terminal MethodDeclaration;
non terminal Type;
non terminal Statement;
non terminal Expression;
non terminal SimpleClassDeclaration;
non terminal ExtendsClassDeclaration;
non terminal VarDeclarations;
non terminal MethodDeclarations;
non terminal ParameterList;
non terminal CommaParameters;
non terminal Statements;
non terminal Operator;
non terminal ExpressionList;
non terminal CommaExpressions;

// why is this a nonterm in the minijava grammar,
// do i need this, do i need 1 for int-literal?
// non terminal Identifier;

/* Precedence declarations: */
// todo: precendence
precedence left LBRACK, RBRACK;
precedence left LPAREN, RPAREN;
precedence left DOT;
precedence left NOT;

precedence left AND;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left TIMES;

/* Productions: */
/* ----------- OLD PRODUCTIONS ------------
Program ::= Statement:s
            {: List<Statement> p = new LinkedList<Statement>();
               p.add(s);
               RESULT = p; :}
        | Program:p Statement:s
            {: p.add(s); RESULT = p; :};

Statement   ::= AssignStatement:s
                {: RESULT = s; :};

AssignStatement ::= Identifier:id BECOMES Expression:expr SEMICOLON
                    {: RESULT = new Assign(id, expr, idxleft); :};

Identifier  ::= IDENTIFIER:id
                {: RESULT = new Identifier(id, idxleft); :};

Expression    ::= IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, namexleft); :}
        | Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :};
*/

Goal ::= MainClass ClassDeclarations;

ClassDeclarations ::= ClassDeclarations ClassDeclaration | /* epsilon */;

MainClass ::= CLASS IDENTIFIER LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK IDENTIFIER RPAREN LCURLY Statement RCURLY RCURLY;

ClassDeclaration ::= SimpleClassDeclaration | ExtendsClassDeclaration;
SimpleClassDeclaration ::= CLASS IDENTIFIER LCURLY VarDeclarations MethodDeclarations RCURLY;
ExtendsClassDeclaration ::= CLASS IDENTIFIER EXTENDS IDENTIFIER LCURLY VarDeclarations MethodDeclarations RCURLY;

VarDeclarations ::= VarDeclarations VarDeclaration | /* epsilon */;

MethodDeclarations ::= MethodDeclarations MethodDeclaration | /* epsilon */;

VarDeclaration ::= Type IDENTIFIER SEMICOLON;

MethodDeclaration ::= PUBLIC Type IDENTIFIER LPAREN ParameterList RPAREN LCURLY VarDeclarations Statements RETURN Expression SEMICOLON RCURLY;

ParameterList ::= Type IDENTIFIER CommaParameters | /* epsilon */;
CommaParameters ::= COMMA Type IDENTIFIER CommaParameters | /* epsilon */;

Statements ::= Statement Statements | /* epsilon */;

Type ::= INT LBRACK RBRACK 
        | BOOLEAN 
        | INT 
        | IDENTIFIER;

Statement ::= LCURLY Statements RCURLY | IF LPAREN Expression RPAREN Statement ELSE Statement
            | WHILE LPAREN Expression RPAREN Statement 
            | PRINT LPAREN Expression RPAREN SEMICOLON
            | IDENTIFIER BECOMES Expression SEMICOLON 
            | IDENTIFIER LBRACK Expression RBRACK BECOMES Expression SEMICOLON;

Operator ::= AND | LESSTHAN | PLUS | MINUS | TIMES;

ExpressionList ::= Expression CommaExpressions | /* epsilon */;
CommaExpressions ::= COMMA Expression CommaExpressions | /* epsilon */;

Expression ::= Expression Operator Expression
            | Expression LBRACK Expression RBRACK
            | Expression DOT LENGTH
            | Expression DOT IDENTIFIER LPAREN ExpressionList RPAREN
            | INTEGER_LITERAL
            | TRUE
            | FALSE
            | IDENTIFIER
            | THIS
            | NEW INT LBRACK Expression RBRACK
            | NEW IDENTIFIER LPAREN RPAREN
            | NOT Expression
            | LPAREN Expression RPAREN;