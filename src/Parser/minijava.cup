/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal CLASS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal STRING;
terminal EXTENDS;
terminal RETURN;
terminal INT;
terminal BOOLEAN;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PRINT;
terminal TRUE;
terminal FALSE;
terminal THIS;
terminal NEW;
terminal LENGTH;

/* operators */
terminal PLUS, BECOMES;
terminal AND, NOT;
terminal LESSTHAN;
terminal MINUS, TIMES;

/* delimiters */
terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal LCURLY, RCURLY;
terminal SEMICOLON, COMMA, DOT;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

/* ------------ OLD NONTERMINALS --------------
non terminal List<Statement> Program;
non terminal Statement Statement;
non terminal Assign AssignStatement;
non terminal Exp Expression;
non terminal Identifier Identifier;
*/
// todo: add types to these, corresponding to the AST node type for the given
// production (i think)
non terminal Goal;
non terminal MainClass;
non terminal ClassDeclarations;
non terminal ClassDeclaration;
non terminal VarDeclaration;
non terminal MethodDeclaration;
non terminal Type;
non terminal Statement;
non terminal Exp Expression;
non terminal SimpleClassDeclaration;
non terminal ExtendsClassDeclaration;
non terminal VarDeclarations;
non terminal MethodDeclarations;
non terminal ParameterList;
non terminal CommaParameters;
non terminal Statements;
non terminal Operator;
non terminal ExpressionList;
non terminal CommaExpressions;
non terminal Identifier Identifier;

// why is this a nonterm in the minijava grammar,
// do i need this, do i need 1 for int-literal?
// non terminal Identifier;

/* Precedence declarations: */
// todo: precendence
precedence left LBRACK, RBRACK;
precedence left LPAREN, RPAREN;
precedence left DOT;
precedence left NOT;

precedence left AND;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left TIMES;

/* Productions: */
/* ----------- OLD PRODUCTIONS ------------
Program ::= Statement:s
            {: List<Statement> p = new LinkedList<Statement>();
               p.add(s);
               RESULT = p; :}
        | Program:p Statement:s
            {: p.add(s); RESULT = p; :};

Statement   ::= AssignStatement:s
                {: RESULT = s; :};

AssignStatement ::= Identifier:id BECOMES Expression:expr SEMICOLON
                    {: RESULT = new Assign(id, expr, idxleft); :};

Identifier  ::= IDENTIFIER:id
                {: RESULT = new Identifier(id, idxleft); :};

Expression    ::= IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, namexleft); :}
        | Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :};
*/

Goal ::= MainClass ClassDeclarations;

ClassDeclarations ::= ClassDeclarations ClassDeclaration | /* epsilon */;

MainClass ::= CLASS Identifier LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK Identifier RPAREN LCURLY Statement RCURLY RCURLY;

ClassDeclaration ::= SimpleClassDeclaration | ExtendsClassDeclaration;
SimpleClassDeclaration ::= CLASS Identifier LCURLY VarDeclarations MethodDeclarations RCURLY;
ExtendsClassDeclaration ::= CLASS Identifier EXTENDS Identifier LCURLY VarDeclarations MethodDeclarations RCURLY;

VarDeclarations ::= VarDeclarations VarDeclaration | /* epsilon */;
VarDeclaration ::= Type Identifier SEMICOLON;

MethodDeclarations ::= MethodDeclaration MethodDeclarations | /* epsilon */;
MethodDeclaration ::= PUBLIC Type Identifier LPAREN ParameterList RPAREN LCURLY VarDeclarations Statements RETURN Expression SEMICOLON RCURLY;

ParameterList ::= Type Identifier CommaParameters | /* epsilon */;
CommaParameters ::= COMMA Type Identifier CommaParameters | /* epsilon */;

Statements ::= Statement Statements | /* epsilon */;
Statement ::= LCURLY Statements RCURLY 
            | IF LPAREN Expression RPAREN Statement ELSE Statement
            | WHILE LPAREN Expression RPAREN Statement 
            | PRINT LPAREN Expression RPAREN SEMICOLON
            | Identifier BECOMES Expression SEMICOLON 
            | Identifier LBRACK Expression RBRACK BECOMES Expression SEMICOLON;

Type ::= INT LBRACK RBRACK 
        | BOOLEAN 
        | INT 
        | Identifier;

ExpressionList ::= Expression CommaExpressions | /* epsilon */;
CommaExpressions ::= COMMA Expression CommaExpressions | /* epsilon */;

Expression ::= Expression:e1 TIMES Expression:e2
                {: RESULT = new Times(e1, e2, e1xleft); :}
            | Expression:e1 MINUS Expression:e2
                {: RESULT = new Minus(e1, e2, e1xleft); :}
            | Expression:e1 PLUS Expression:e2
                {: RESULT = new Plus(e1, e2, e1xleft); :}
            | Expression:e1 LESSTHAN Expression:e2
                {: RESULT = new LessThan(e1, e2, e1xleft); :}
            | Expression:e1 AND Expression:e2
                {: RESULT = new And(e1, e2, e1xleft); :}
            | Expression:e1 LBRACK Expression:e2 RBRACK
                {: RESULT = new ArrayLookup(e1, e2, e1xleft); :}
            | Expression:e1 DOT LENGTH
                {: RESULT = new ArrayLength(e1, e1xleft); :}
            | Expression:e1 DOT Identifier:id LPAREN ExpressionList:e2 RPAREN
                {: RESULT = new Call(e1, id, e2, e1xleft); :}
            | INTEGER_LITERAL:e
                {: RESULT = new IntegerLiteral(Integer.parseInt((String)e.value), exleft); :}
            | TRUE:e
                {: RESULT = new True(exleft); :}
            | FALSE:e
                {: RESULT = new False(exleft); :}
            | IDENTIFIER:id
                {: RESULT = new IdentifierExpression((String)id.value, idxleft); :}
            | THIS:e
                {: RESULT = new This(exleft); :}
            | NEW:n INT LBRACK Expression:e RBRACK
                {: RESULT = new NewArray(e, nxleft); :}
            | NEW:n Identifier:id LPAREN RPAREN
                {: RESULT = new NewObject(id, nxleft); :}
            | NOT:n Expression:e
                {: RESULT = new Not(e, nxleft); :}
            | LPAREN Expression:e RPAREN
                {: RESULT = e; :};

Identifier ::= IDENTIFIER:e
                {: RESULT = new Identifier((String)e.value, exleft) :};     